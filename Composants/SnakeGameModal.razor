@using NuitInfo.Rubeus.Modeles.SnakeGame
@using NuitInfo.Rubeus.Repositories
@using Microsoft.AspNetCore.Components
@inject IJSRuntime JS
@inject ISnakeGameEngine GameEngine
@implements IAsyncDisposable

@if (isOpen)
{
    <div class="snake-modal-overlay" @onclick="OnOverlayClick"></div>
    <div class="snake-modal">
        <div class="snake-modal-header">
            <h2>üêç Snake Game</h2>
            <button class="snake-modal-close" @onclick="Close">&times;</button>
        </div>

        <div class="snake-modal-content">
            <div class="snake-game-stats">
                <div class="stat">
                    <span class="stat-label">Score:</span>
                    <span class="stat-value">@gameState?.Score</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Longueur:</span>
                    <span class="stat-value">@gameState?.Length</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Temps:</span>
                    <span class="stat-value">@FormatTime(gameState?.ElapsedMs ?? 0)</span>
                </div>
            </div>

            @if (gameState != null)
            {
                var viewBoxValue = $"0 0 {gameState.GridWidth} {gameState.GridHeight}";
                <div class="game-board-wrapper">
                    <svg class="game-canvas-modal" viewBox="@viewBoxValue">
                            <!-- Grille de fond - image tile with subtle prison bars -->
                            <defs>
                                <pattern id="grid-modal" x="0" y="0" width="6" height="6" patternUnits="userSpaceOnUse">
                                    <image href="/images/Prison.png" x="0" y="0" width="6" height="6" preserveAspectRatio="none" />
                                </pattern>
                            </defs>
                            <rect width="@gameState.GridWidth" height="@gameState.GridHeight" fill="#151515" stroke="#333" stroke-width="0.1"/>
                            <rect width="@gameState.GridWidth" height="@gameState.GridHeight" fill="url(#grid-modal)"/>

                        <!-- Nourriture sp√©ciale -->
                        @if (gameState.SpecialFood != null)
                        {
                            <circle cx="@(gameState.SpecialFood.X + 0.5)" cy="@(gameState.SpecialFood.Y + 0.5)" r="0.35" fill="#FFD700" class="special-food"/>
                        }

                        <!-- Nourriture normale (image - book) -->
                        @if (gameState.Food != null)
                        {
                            <image x="@(gameState.Food.X - 0.3)" y="@(gameState.Food.Y - 0.3)" width="1.6" height="1.6" href="/images/1.png" preserveAspectRatio="xMidYMid meet" class="food" />
                        }

                        <!-- Corps du serpent (render body segments first so head appears above) -->
                        @if (gameState.SnakeBody.Count > 0)
                        {
                            @for (int i = 1; i < gameState.SnakeBody.Count; i++)
                            {
                                var segment = gameState.SnakeBody[i];
                                var opacityValue = 1 - i * 0.02;
                                var prev = gameState.SnakeBody[i - 1];
                                var dx = prev.X - segment.X;
                                var dy = prev.Y - segment.Y;
                                var segAngle = dx == 1 ? 0 : dx == -1 ? 180 : dy == 1 ? 90 : dy == -1 ? -90 : 0;
                                var adjustedSegAngle = segAngle + 90;
                                var cx = segment.X + 0.5;
                                var cy = segment.Y + 0.5;
                                if (i == gameState.SnakeBody.Count - 1)
                                {
                                    <image x="@segment.X" y="@segment.Y" width="1" height="1" href="/images/tail.png" preserveAspectRatio="xMidYMid meet" opacity="@opacityValue" class="snake-tail" transform="rotate(@adjustedSegAngle @cx @cy)" />
                                }
                                else
                                {
                                    <image x="@segment.X" y="@segment.Y" width="1" height="1" href="/images/middle.png" preserveAspectRatio="xMidYMid meet" opacity="@opacityValue" class="snake-middle" transform="rotate(@adjustedSegAngle @cx @cy)" />
                                }
                            }
                        }

                        <!-- Head rendered last so it appears above body and food -->
                        @if (gameState.SnakeBody.Count > 0)
                        {
                            var head = gameState.SnakeBody[0];
                            var angle = gameState.CurrentDirection switch
                            {
                                Direction.Up => -90,
                                Direction.Down => 90,
                                Direction.Left => 180,
                                Direction.Right => 0,
                                _ => 0
                            };
                            var adjustedAngle = angle + 90; // rotate head image 90¬∞ to the right
                            var cx = head.X + 0.5;
                            var cy = head.Y + 0.5;

                            <image x="@(head.X - 0.5)" y="@(head.Y - 0.5)" width="2.0" height="2.0" href="/images/image.png" preserveAspectRatio="xMidYMid meet" class="snake-head-image" transform="rotate(@adjustedAngle @cx @cy)" />
                        }
                    </svg>
                    
                    <!-- Message Game Over (overlay) -->
                    @if (gameState.Status == GameStatus.GameOver || gameState.Status == GameStatus.Victory)
                    {
                        var messageText = gameState.Status == GameStatus.Victory ? "üéâ VICTOIRE!" : "üíÄ GAME OVER!";
                        <div class="game-overlay">
                            <div class="game-message">@messageText</div>
                        </div>
                    }
                </div>
            }

            <div class="snake-modal-controls">
                @if (gameState?.Status == GameStatus.NotStarted)
                {
                    <button class="btn btn-play" @onclick="StartGame">
                        ‚ñ∂ Jouer
                    </button>
                }
                else if (gameState?.Status == GameStatus.Playing)
                {
                    <button class="btn btn-pause" @onclick="PauseGame">
                        ‚è∏ Pause
                    </button>
                }
                else if (gameState?.Status == GameStatus.Paused)
                {
                    <button class="btn btn-play" @onclick="ResumeGame">
                        ‚ñ∂ Reprendre
                    </button>
                }

                @if (gameState?.Status == GameStatus.GameOver || gameState?.Status == GameStatus.Victory)
                {
                    <button class="btn btn-restart" @onclick="RestartGame">
                        üîÑ Recommencer
                    </button>
                }

                <button class="btn btn-close-modal" @onclick="Close">
                    ‚úï Fermer
                </button>
            </div>

            <div class="snake-instructions-modal">
                <p><strong>Contr√¥les:</strong> Fl√®ches ‚Üë‚Üì‚Üê‚Üí ou WASD | Espace: Pause | Entr√©e: D√©marrer</p>
            </div>
        </div>
    </div>
}

@code {
    [Parameter]
    public bool IsOpen { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    private bool isOpen;
    private GameState? gameState;
    private System.Timers.Timer? gameUpdateTimer;
    private const int UpdateIntervalMs = 16; // ~60 FPS
    private DotNetObjectReference<SnakeGameModal>? objRef;

    protected override void OnParametersSet()
    {
        isOpen = IsOpen;
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        GameEngine.Initialize(GameDifficulty.Medium);
        gameState = GameEngine.GetCurrentState();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
            try
            {
                await JS.InvokeVoidAsync("SnakeGame.InitializeKeyboardListener", objRef);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error initializing keyboard listener: {ex.Message}");
            }
        }
        await base.OnAfterRenderAsync(firstRender);
    }

    public async Task Open()
    {
        isOpen = true;
        await InvokeAsync(StateHasChanged);
    }

    public async Task Close()
    {
        isOpen = false;
        gameUpdateTimer?.Stop();
        await OnClose.InvokeAsync();
    }

    private void OnOverlayClick()
    {
        // Peut ignorer le clic sur overlay ou fermer
    }

    [JSInvokable]
    public void HandleArrowUp()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Up);
        }
    }

    [JSInvokable]
    public void HandleArrowDown()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Down);
        }
    }

    [JSInvokable]
    public void HandleArrowLeft()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Left);
        }
    }

    [JSInvokable]
    public void HandleArrowRight()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Right);
        }
    }

    [JSInvokable]
    public void HandleW()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Up);
        }
    }

    [JSInvokable]
    public void HandleS()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Down);
        }
    }

    [JSInvokable]
    public void HandleA()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Left);
        }
    }

    [JSInvokable]
    public void HandleD()
    {
        if (isOpen && gameState?.Status == GameStatus.Playing)
        {
            GameEngine.SetNextDirection(Direction.Right);
        }
    }

    [JSInvokable]
    public void HandleEnter()
    {
        if (!isOpen) return;

        if (gameState?.Status == GameStatus.NotStarted)
        {
            StartGame();
        }
        else if (gameState?.Status == GameStatus.GameOver || gameState?.Status == GameStatus.Victory)
        {
            RestartGame();
        }
    }

    [JSInvokable]
    public void HandleSpace()
    {
        if (!isOpen) return;

        if (gameState?.Status == GameStatus.NotStarted)
        {
            StartGame();
        }
        else if (gameState?.Status == GameStatus.Playing)
        {
            PauseGame();
        }
        else if (gameState?.Status == GameStatus.Paused)
        {
            ResumeGame();
        }
    }

    private void StartGame()
    {
        GameEngine.Start();
        gameState = GameEngine.GetCurrentState();
        StartGameLoop();
    }

    private void PauseGame()
    {
        GameEngine.Pause();
        gameState = GameEngine.GetCurrentState();
        StateHasChanged();
    }

    private void ResumeGame()
    {
        GameEngine.Resume();
        gameState = GameEngine.GetCurrentState();
        StateHasChanged();
    }

    private void RestartGame()
    {
        gameUpdateTimer?.Stop();
        GameEngine.Reset();
        gameState = GameEngine.GetCurrentState();
        StateHasChanged();
    }

    private void StartGameLoop()
    {
        gameUpdateTimer = new System.Timers.Timer(UpdateIntervalMs);
        gameUpdateTimer.Elapsed += async (s, e) =>
        {
            GameEngine.Update();
            gameState = GameEngine.GetCurrentState();

            await InvokeAsync(StateHasChanged);

            if (gameState.Status != GameStatus.Playing)
            {
                gameUpdateTimer?.Stop();
            }
        };
        gameUpdateTimer.Start();
    }

    private string FormatTime(long ms)
    {
        var totalSeconds = ms / 1000;
        var minutes = totalSeconds / 60;
        var seconds = totalSeconds % 60;
        return $"{minutes:D2}:{seconds:D2}";
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (gameUpdateTimer != null)
        {
            gameUpdateTimer.Stop();
            gameUpdateTimer.Dispose();
        }
        objRef?.Dispose();
        await Task.CompletedTask;
    }
}
