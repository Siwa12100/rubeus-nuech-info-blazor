@using NuitInfo.Rubeus.PcRescue.Models
@using System.Diagnostics
@implements IDisposable

<div class="qte-overlay" @onclick="HandleClick">
    <div class="qte-container" @onclick="HandleClick" @onclick:stopPropagation="true">
        <h2 class="qte-title">⚡ Extraction en cours...</h2>
        <p class="qte-instruction">Cliquez quand l'aiguille est dans la zone verte !</p>

        <div class="qte-circle-wrapper">
            <!-- Cercle avec zones de couleur -->
            <svg class="qte-circle" viewBox="0 0 200 200">
                <!-- Cercle de fond gris -->
                <circle cx="100" cy="100" r="85" fill="none" stroke="#e5e7eb" stroke-width="25"/>

                <!-- Zone Fail (rouge) - tout le cercle par défaut -->
                <circle cx="100" cy="100" r="85" fill="none" stroke="#ef4444" stroke-width="25"
                        stroke-dasharray="534" stroke-dashoffset="0"/>

                <!-- Zone Medium (jaune) -->
                <circle cx="100" cy="100" r="85" fill="none" stroke="#eab308" stroke-width="25"
                        stroke-dasharray="@_mediumDashArray" stroke-dashoffset="@_mediumDashOffset"
                        transform="rotate(@_zoneRotation 100 100)"/>

                <!-- Zone Perfect (vert) -->
                <circle cx="100" cy="100" r="85" fill="none" stroke="#22c55e" stroke-width="25"
                        stroke-dasharray="@_perfectDashArray" stroke-dashoffset="@_perfectDashOffset"
                        transform="rotate(@_zoneRotation 100 100)"/>

                <!-- Centre -->
                <circle cx="100" cy="100" r="50" fill="#1f2937"/>
            </svg>

            <!-- Aiguille qui tourne -->
            <div class="qte-needle" style="animation-duration: @(_speed)ms;"></div>

            <!-- Indicateur au centre -->
            <div class="qte-center-dot"></div>
        </div>

        <div class="qte-help">
            <div class="help-item">
                <span class="color-indicator perfect"></span>
                <span>Parfait (+0 dégâts)</span>
            </div>
            <div class="help-item">
                <span class="color-indicator medium"></span>
                <span>Moyen (risque de dégâts)</span>
            </div>
            <div class="help-item">
                <span class="color-indicator fail"></span>
                <span>Raté (dégâts assurés)</span>
            </div>
        </div>

        <button class="qte-close-btn" @onclick="HandleClose">✕</button>
    </div>
</div>

<style>
    .qte-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        animation: fadeIn 0.2s ease-out;
    }

    @@keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .qte-container {
        background: white;
        border-radius: 20px;
        padding: 40px;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        max-width: 500px;
        position: relative;
        animation: scaleIn 0.3s ease-out;
    }

    @@keyframes scaleIn {
        from { transform: scale(0.9); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }

    .qte-title {
        color: #1f2937;
        margin: 0 0 10px 0;
        font-size: 1.8em;
    }

    .qte-instruction {
        color: #6b7280;
        margin: 0 0 30px 0;
        font-size: 1.1em;
    }

    .qte-circle-wrapper {
        position: relative;
        width: 280px;
        height: 280px;
        margin: 0 auto 30px;
    }

    .qte-circle {
        width: 100%;
        height: 100%;
    }

    .qte-needle {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 110px;
        background: linear-gradient(to bottom, #dc2626 0%, #dc2626 50%, transparent 50%);
        transform-origin: bottom center;
        transform: translate(-50%, -100%);
        animation: rotate 2s linear infinite;
        z-index: 10;
    }

    @@keyframes rotate {
        from { transform: translate(-50%, -100%) rotate(0deg); }
        to { transform: translate(-50%, -100%) rotate(360deg); }
    }

    .qte-center-dot {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 16px;
        height: 16px;
        background: #dc2626;
        border-radius: 50%;
        transform: translate(-50%, -50%);
        z-index: 11;
        box-shadow: 0 0 10px rgba(220, 38, 38, 0.5);
    }

    .qte-help {
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
        padding: 20px;
        background: #f9fafb;
        border-radius: 12px;
    }

    .help-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9em;
        color: #374151;
    }

    .color-indicator {
        width: 20px;
        height: 20px;
        border-radius: 50%;
    }

    .color-indicator.perfect {
        background: #22c55e;
    }

    .color-indicator.medium {
        background: #eab308;
    }

    .color-indicator.fail {
        background: #ef4444;
    }

    .qte-close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 35px;
        height: 35px;
        border: none;
        background: #f3f4f6;
        border-radius: 50%;
        font-size: 1.2em;
        cursor: pointer;
        color: #6b7280;
        transition: all 0.2s;
    }

    .qte-close-btn:hover {
        background: #e5e7eb;
        color: #374151;
        transform: scale(1.1);
    }

    /* Responsive */
    @@media (max-width: 600px) {
        .qte-container {
            padding: 30px 20px;
            margin: 20px;
        }

        .qte-circle-wrapper {
            width: 220px;
            height: 220px;
        }

        .qte-help {
            flex-direction: column;
            gap: 10px;
        }
    }
</style>

@code {
    [Parameter]
    public EventCallback<QteResult> OnFinished { get; set; }

    // Configuration des zones (en pourcentage du cercle)
    private double _perfectZoneSize = 15; // 15% du cercle
    private double _mediumZoneSize = 30;  // 30% du cercle (15% de chaque côté du perfect)

    // Rotation aléatoire de la zone de succès
    private double _zoneRotation = 0;

    // Vitesse de rotation de l'aiguille
    private int _speed = 2000; // 2 secondes par tour

    // Variables pour le SVG
    private string _perfectDashArray = "";
    private string _perfectDashOffset = "";
    private string _mediumDashArray = "";
    private string _mediumDashOffset = "";

    // Chronomètre pour synchroniser le calcul d'angle avec l'animation CSS
    private readonly Stopwatch _stopwatch = new();
    private bool _started;

    protected override void OnInitialized()
    {
        // Randomiser la position de la zone de succès
        var random = new Random();
        _zoneRotation = random.Next(0, 360);

        // Randomiser légèrement la vitesse
        _speed = random.Next(1500, 2500);

        // Calculer les dasharray et dashoffset pour les zones
        double circumference = 2 * Math.PI * 85; // 2πr

        // Zone Perfect
        double perfectLength = (circumference * _perfectZoneSize) / 100;
        _perfectDashArray = $"{perfectLength} {circumference}";
        _perfectDashOffset = "0";

        // Zone Medium (englobe Perfect)
        double mediumLength = (circumference * _mediumZoneSize) / 100;
        _mediumDashArray = $"{mediumLength} {circumference}";
        // Offset pour centrer Medium autour de Perfect
        double mediumOffset = -((mediumLength - perfectLength) / 2);
        _mediumDashOffset = $"{mediumOffset}";
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && !_started)
        {
            _stopwatch.Start();
            _started = true;
        }
        return Task.CompletedTask;
    }

    private async Task HandleClick()
    {
        // Calculer l'angle actuel de l'aiguille
        var elapsedMs = _stopwatch.IsRunning ? _stopwatch.ElapsedMilliseconds : 0;
        var currentAngle = (elapsedMs % _speed) * 360.0 / _speed;

        // Convertir l'angle de l'aiguille (CSS: 0° = 12h) vers le repère du cercle SVG (0° = 3h)
        // 12h (CSS 0°) correspond à 270° en SVG (car 0° SVG = 3h). Donc on soustrait 90°.
        var needleAngleSvg = (currentAngle - 90 + 360) % 360;

        // Normaliser les angles
        // Les tailles de zones sont exprimées en pourcentage: convertir en degrés
        var perfectDeg = 360.0 * _perfectZoneSize / 100.0;
        var mediumDeg = 360.0 * _mediumZoneSize / 100.0;

        // Le SVG dessine la zone Perfect en démarrant à _zoneRotation; son centre visuel est donc à _zoneRotation + perfectDeg/2
        var zoneCenter = (_zoneRotation + perfectDeg / 2 + 360) % 360;

        var normalizedAngle = (needleAngleSvg + 360) % 360;
        var normalizedZoneStart = (zoneCenter - mediumDeg / 2 + 360) % 360;
        var normalizedZoneEnd = (zoneCenter + mediumDeg / 2 + 360) % 360;
        var normalizedPerfectStart = (zoneCenter - perfectDeg / 2 + 360) % 360;
        var normalizedPerfectEnd = (zoneCenter + perfectDeg / 2 + 360) % 360;

        QteResult result;

        // Vérifier si dans la zone Perfect
        if (IsAngleInRange(normalizedAngle, normalizedPerfectStart, normalizedPerfectEnd))
        {
            result = QteResult.Perfect;
        }
        // Vérifier si dans la zone Medium
        else if (IsAngleInRange(normalizedAngle, normalizedZoneStart, normalizedZoneEnd))
        {
            result = QteResult.Medium;
        }
        else
        {
            result = QteResult.Fail;
        }

        await OnFinished.InvokeAsync(result);
    }

    private async Task HandleClose()
    {
        // Fermer sans résultat = considéré comme Fail
        await OnFinished.InvokeAsync(QteResult.Fail);
    }

    private bool IsAngleInRange(double angle, double start, double end)
    {
        // Gérer le cas où la zone traverse 0°
        if (start > end)
        {
            return angle >= start || angle <= end;
        }
        return angle >= start && angle <= end;
    }

    public void Dispose()
    {
        // Nettoyage
        if (_stopwatch.IsRunning)
        {
            _stopwatch.Stop();
        }
    }
}
